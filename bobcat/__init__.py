"""
============
Bobcat
============
A semantic documentation utility.

Objective
=============
Render System Metadata into ReStructuredText, for Sphinx.


References
============
- http://code.google.com/p/fuxi/wiki/FuXiUserManual
- http://packages.python.org/ordf/vocabulary.html#vocabulary-modules

Dependencies
=============
FuXi 1.1 (RDFLib > 2.4.0 < 3a)

"""
import copy
from rdflib.Graph import ConjunctiveGraph
from rdflib import Namespace #, URIRef
import datetime

RDF = Namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
RDFS = Namespace('http://www.w3.org/2000/01/rdf-schema#')
SYS = Namespace('http://ns.ponykeg/ns/systems#')
DOAP = Namespace('http://usefulinc.com/ns/doap#')
NAMESPACES = {
        'rdf': RDF,
        'rdfs': RDFS,
        'sys': SYS,
        'doap': DOAP,
}

def load_graph(schema, data, additional=None, debug=False):
    """
    Load the specified schema, extract rules,
    load data and any additional ontologies,
    and infer facts.

    :param schema: Schema Graph
    :type schema: `rdflib.ConjunctiveGraph`
    :param components: Component Graph
    :type components: `rdflib.ConjunctiveGraph`
    :param debug: Whether to print debugging information
    :type debug: bool

    :returns: (Graph w/ inferred facts, Graph w/o inferred facts)
    :rtype: tuple(`rdflib.ConjunctiveGraph`,
                  `rdflib.ConjunctiveGraph`)

    """
    from FuXi.Rete.Util import generateTokenSet
    from FuXi.DLP.DLNormalization import NormalFormReduction
    from FuXi.Rete.RuleStore import SetupRuleStore
    rule_store, rule_graph, network = SetupRuleStore(makeNetwork=True)

    additional_schema = ConjunctiveGraph()
    len_additional = 0
    if additional:
        for g in additional:
            additional_schema += g
            len_additional += len(g)

    len_schema = len(schema)
    len_data = len(data)

    schema += additional_schema

    NormalFormReduction(schema)
    network.setupDescriptionLogicProgramming(schema)
    network.feedFactsToAdd(generateTokenSet(schema))
    network.feedFactsToAdd(generateTokenSet(data))

    if debug:
        print network

        print dir(network)

        for r in network.rules:
            print r

        for f in network.inferredFacts:
            print f

    len_inferred = len(network.inferredFacts)

    print "==================="
    print "Component Reference"
    print "==================="
    print "Report Information"
    print "=================="
    print "Generated by Bobcat @ %s" % datetime.datetime.now()
    print ""
    print ".. list-table::"
    print "   :header-rows: 1"
    print ""
    print rest_list_table_row(["Graph","Triple Count"])
    print rest_list_table_row(["Schema", len_schema])
    print rest_list_table_row(["Additional", len_additional])
    print rest_list_table_row(["Data", len_data])
    print rest_list_table_row(["",""])
    print rest_list_table_row(["Inferred", len_inferred])
    print rest_list_table_row(["",""])
    print rest_list_table_row(["Subtotal",
        len_schema + len_data + len_inferred + len_additional])
    print rest_list_table_row(["",""])



    gall = schema
    gall += data
    if additional:
        for g in additional:
            gall += g

    gall_inferred = copy.deepcopy(gall)

    for f in network.inferredFacts:
        gall_inferred.add(f)

    print rest_list_table_row(["Union Total",len(gall_inferred)])

    return gall_inferred, gall

def main():
    """
    console_entrypoint for the bobcat utility
    """
    import optparse

    prs = optparse.OptionParser(
        usage =('%prog -s <schema> <fmt>'
                ' -d <data> <fmt>'
                ' [-a <path> <fmt>]'
                ' [-o <path> ]'),
        description = "A semantic documentation tool"
    )

    prs.add_option('-s','--schema',dest='schema', action='store', nargs=2,
            help='Load the specified tBox/Schema Ontology ')
    prs.add_option('-d','--data',dest='data',action='store',nargs=2,
            help='Load the specified data ontology ')
    prs.add_option('-a','--add',dest='additional', action="append",nargs=2,
        help="Load the specified additional onotology",
        default=[])

    # Not Yet Implemented
    prs.add_option('-o','--output-file',dest='output',action='store',
        help="Destination file to write output to")

    (opts,args) = prs.parse_args()

    if not (opts.schema and opts.data):
        print "At a minimum, both a schema and data ontology must be specified"
        exit(1)
    else:
        # Load graphs
        gschema = ConjunctiveGraph().parse(
            opts.schema[0],
            format=opts.schema[1])
        gdata = ConjunctiveGraph().parse(
            opts.data[0],
            format=opts.data[1])

        additional = []
        for (path,format) in opts.additional:
            additional.append(
                ConjunctiveGraph().parse(path, format=format)
            )

        # Add inferred facts
        gall_inferred, gall = load_graph(gschema, gdata, additional=additional)

        # Print as ReStructuredText
        print_rest(gall_inferred, gall)

    return

# FIXME: REST injection
def rest_format_predicate(uri=None, label=None):
    """
    :param uri: URIRef
    :type uri: `rdflib.URIRef`
    :param label: RDFS Label (or equivalent)
    :type label: str

    :returns: ReStructuredText-formatted predicate
    :rtype: str
    """
    if uri and label:
        label = label.encode('ascii','xmlcharrefreplace')
        label = label.replace('`','')
        label = label.replace('<','&laquote;')
        label = label.replace('>', '&raquote;')
        return u'`{0} <{1}>`_'.format(label, uri)
    return uri

def rest_list_table_row(values, indent=3):
    """
    :param args: column values
    :type args: list

    :returns: ReStructuredText-formatted List-table row
    :rtype: str
    """
    indent = indent * ' '
    rows = ['%s* - %s' % (indent,values.pop(0))]
    for value in values:
        rows.append('%s  - %s' % (indent,value))
    return '\n'.join(rows)

FILTER_PREDICATES = [
DOAP["name"], # Already displayed in header
None
]
def format_component_row(row):
    """
    Format a component attribute row

    :param row: (predicate, predicate_label, object, object_label)
    :type row: tuple

    :returns: None if the row should be filtered out. Otherwise a
        ReStructuredText representation of the row
    :rtype: None or str
    """
    (p, p_label, o, o_label) = row
    if p_label and p_label.language is not None and p_label.language != "en":
        return False
    if o_label and o_label.language is not None and o_label.language != "en":
        return False
    if p in FILTER_PREDICATES:
        return False
    return [
        rest_format_predicate(p, p_label),
        rest_format_predicate(o, o_label)
    ]

def rest_list_table(query,formatter,name=None):
    """
    Generate a formatted ReStructuredText List-Table by formatting the 'rows'
    in query with the specified formatter

    :param query: [(predicate, predicate_label,
                    object, object_label),...]
    :type query: list(tuple)
    :param formatter: callable that returns a string or False for each row
    :type formatter: callable
    :param name: Optional list-table name
    :type name: str

    :returns: None
    """

    print ".. list-table:: %s" % name or ''
    print "   :header-rows: 1"
    print ""

    print rest_list_table_row(["Predicate", "Object"], indent=3)

    for row in query:
        formatted = formatter(row)
        if formatted:
            print rest_list_table_row(formatted, indent=3)


def print_rest(ginferred, gall):
    """
    Given a graph, print a ReStructuredText summary to sys.stdout

    :param ginferred: Graph including inferred facts
    :type ginferred: `rdflib.ConjunctiveGraph`
    :param gall: Graph not including inferred facts
    :type gall: `rdflib.ConjunctiveGraph`

    :returns: None
    """

    print ""
    print "Components"
    print "=========="

    #print project_names.keys()
    components = ginferred.query("""
    SELECT ?component ?name
    WHERE {
        ?component rdf:type sys:Component
        OPTIONAL { ?component doap:name ?name }
    }
    ORDER BY ?component ?name
    """,initNs=NAMESPACES)

    for component in components:
        component,name = component
        name = name or component

        print ''
        print name
        print '-'*len(name)
        query = ginferred.query("""
        SELECT DISTINCT ?p ?pred_label ?o ?obj_label
        WHERE {
            <%s> ?p ?o .
            OPTIONAL { ?o rdfs:label ?obj_label . }
            OPTIONAL { ?p rdfs:label ?pred_label . }
                FILTER (?o != <http://www.w3.org/2002/07/owl#NamedIndividual>)

        }
        ORDER BY ?p ?o
        """ % component, initNs=NAMESPACES )# FIXME: injection

        rest_list_table(query, format_component_row)

    return None


if __name__=="__main__":
    main()
